#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar  9 11:47:21 2022

@author: marco
"""

import os
import argparse
import subprocess
import MDAnalysis as mda
import MDAnalysis.analysis.leaflet
import numpy as np
import shocker.src.cluster as cl
import shocker.src.file_mod as fm
import shocker.src.index_processing as ip
import shocker.src.vesicle_data as vd
import shocker.src.water_identifier as wi
from shocker.src.cluster import Cluster
from shocker.src.water_identifier import Identifier
from shocker.src.water_repositioning import Mover
from shocker.src.vesicle_data import VolArea
from shocker.src.vesicle_data import IonConcentration
from shocker import DATA_PATH


def main():

    parser = argparse.ArgumentParser(description='Osmotic shock simulator',
                                     add_help=True)
    parser.add_argument('-f', '--mdp',
                        help='mdp file containing input parameters')
    parser.add_argument('-c', '--name',
                        help='name of the files')
    parser.add_argument('-ct', '--restart', default='no',
                        help='restart from last cycle')
    parser.add_argument('-p', '--topology',
                        help='topology file')
    parser.add_argument('-r', '--removed', type=int,
                        help='nr of removed particles per shock')
    parser.add_argument('-e', '--end', type=int,
                        help='nr of the last cycle')
    parser.add_argument('-b', '--bins', type=float, default=1.3,
                        help='bin size for clustering \
                            (standard size is 1nm^3)')
    parser.add_argument('-s', '--start', type=int, default=0,
                        help='define the starting cycle')
    parser.add_argument('-xf', '--xtc', type=int, default=10000,
                        help='frequency of storing position data \
                            (default = 10000)')
    parser.add_argument('-n', '--index',
                        help='index file containing membrane,\
                            solvent and possibly ions')
    parser.add_argument('-it', '--iterations', type=int, default=100000,
                        help='the number of iterations per cycle')
    parser.add_argument('-sts', '--slow_timestep', type=float, default=0.0002,
                        help='timestep of slow run')
    parser.add_argument('-its', '--iterations_slow', type=int, default=1000,
                        help='the number of iterations per cycle')
    parser.add_argument('-pts', '--production_timestep', type=float,
                        default=0.02,
                        help='timestep of production run')
    parser.add_argument('-mdpmin', '--emruns', default='no',
                        help='the .mdp files used for energy minimization')
    parser.add_argument('-vd', '--vesdata', default='no',
                        help='whether or not leaflet area and vesicle volume\
                            is calculated and stored each cycle')
    parser.add_argument('-i', '--ions', default='no',
                        help='whether or not ions are used')
    parser.add_argument('-cp', '--cloudpoints', default='GL1',
                        help='defines which atoms are used to construct a \
                            triangulated surface of the vesicle')
    parser.add_argument('-shock', '--shocktype', default='hypertonic',
                        help='type of osmotick shock \
                            (hypertonic or hypotonic)')
    parser.add_argument('-version', '--gromacs', default='gmx',
                        help='version of the gromacs suite used to perform \
                            simulation')
    parser.add_argument('-mem', '--memname', default='membrane',
                        help='name of the membrane index group')
    parser.add_argument('-water', '--water_name', default='water',
                        help='name of the water index group')
    parser.add_argument('-ions', '--ions_name', default='ions',
                        help='name of the ions index group')
    parser.add_argument('-st', '--steadystate', default='no',
                        help='whether or not the shock sim is followed by \
                            steady state simulation')
    parser.add_argument('-nrst', '--nr_steadystate', type=int, default=5000000,
                        help='length of steady state simulation')
    parser.add_argument('-aa', '--all_atom', default='no',
                        help='is the simulation Martini coarse grained \
                            or all-atom?')
    parser.add_argument('-oxy', '--oxygen_pos', type=int, default=0,
                        help='position of the oxygen atom relative to the \
                            hydrogens (0, 1 or 2)')
    parser.add_argument('-options', '--gmx_options', default='none',
                        help='extra mdrun options file')
    parser.add_argument('-sv', '--search', type=int, default=3,
                        help='defines the distance from the bin edges shocker \
                        looks for suitable locations')
    parser.add_argument('-e', '--eval', type=int, default=10,
                        help='number of evaluation rounds before pumping in \
                            steady-state simulation')
    args = parser.parse_args()

    data_path = DATA_PATH

    # =========================================================================
    # Creating the universe and initial gro file
    # =========================================================================

    if os.path.exists('shockfiles') == False:
        gro_file_original = args.name

    else:
        if args.start != 0:
            subprocess.call('rm osmotic_shock*', shell=True)

            for filename in os.listdir('shockfiles'):

                if filename.split('.')[-1] == 'gro' and len(filename.split('_')) == 3:
                    nr = int(filename.split('_')[-1][1:-4])

                    if nr == args.start - 1:
                        restart = filename
                        gro_file_original = 'shockfiles/' + restart
                        restart_cycle = args.start
                    else:
                        print('The pumping cycle you would like to restart does not exist.')

        else:
            subprocess.call('rm osmotic_shock*', shell=True)
            last = 0
            last_file = 'first'

            for filename in os.listdir('shockfiles'):

                if filename.split('.')[-1] == 'gro' and len(filename.split('_')) == 3:

                    sp1 = filename.split('_')[-1]
                    sp2 = sp1.split('s')[-1]
                    sp3 = int(sp2.split('.')[0])

                    if sp3 > last:
                        last = sp3
                        last_file = filename
            restart = last_file
            restart_cycle = last + 1

            gro_file_original = 'shockfiles/' + restart

    copy_command = 'cp {} osmotic_shock.gro'.format(gro_file_original)
    subprocess.call(copy_command, shell=True)
    gro_file = 'osmotic_shock.gro'
    topology_file = args.topology
    tpr_file = 'osmotic_shock.tpr'
    u = mda.Universe(gro_file)

    # =========================================================================
    # Defining and modifying mdp files
    # =========================================================================

    mdp_file = args.mdp
    copy_command_mdp = 'cp {} mdp_file_slow.mdp'.format(mdp_file)
    subprocess.call(copy_command_mdp, shell=True)
    mdp_file2 = 'mdp_file_slow.mdp'

    # mdp_file_path = os.path.join(data_path, 'martini_md_anis.mdp')
    # mdp_file2_path = os.path.join(data_path, 'martini_md_anis_slow.mdp')
    mdp_min = os.path.join(data_path, 'min.mdp')
    # copy_command_mdp = 'cp {} martini_md_anis.mdp'.format(mdp_file_path)
    # copy_command_mdp2 = 'cp {} martini_md_anis_slow.mdp'.format(mdp_file2_path)
    # subprocess.call(copy_command_mdp, shell=True)
    # subprocess.call(copy_command_mdp2, shell=True)
    # mdp_file = 'martini_md_anis.mdp'
    # mdp_file2 = 'martini_md_anis_slow.mdp'
    fm.mdp_value_changer(mdp_file, 'new.mdp', 'nsteps', args.iterations)
    fm.mdp_value_changer(mdp_file2, 'new.mdp', 'nsteps', args.iterations_slow)
    fm.mdp_value_changer(mdp_file, 'new.mdp', 'nstxout-compressed', args.xtc)
    # group_names = ip.ag_extractor(u, args.index)[1]
    # name_string = ip.name_concatenator(group_names)
    # fm.mdp_value_changer(mdp_file, 'new.mdp', 'tc-grps', name_string)
    # fm.mdp_value_changer(mdp_file2, 'new.mdp', 'tc-grps', name_string)
    # taut = '1.0 '*len(group_names)
    # reft = '310 '*len(group_names)
    # fm.mdp_value_changer(mdp_file, 'new.mdp', 'tau_t', taut)
    # fm.mdp_value_changer(mdp_file2, 'new.mdp', 'tau_t', taut)
    # fm.mdp_value_changer(mdp_file, 'new.mdp', 'ref_t', reft)
    # fm.mdp_value_changer(mdp_file2, 'new.mdp', 'ref_t', reft)
    fm.mdp_value_changer(mdp_file, 'new.mdp', 'dt', args.production_timestep)
    fm.mdp_value_changer(mdp_file2, 'new.mdp', 'dt', args.slow_timestep)

    # =========================================================================
    # Starting the pumping cycles
    # =========================================================================

    V0 = 0
    Ad0 = 0
    rupture = 'no'
    shock_go = 'yes'
    shocktype = args.shocktype
    remember_ss = 'no'

    if shocktype == 'steadystate':
        remember_ss = 'yes'

    if os.path.exists('shockfiles') == False:
        start = 0
    else:
        start = restart_cycle

    # creating a destination folder to store all generated files
    subprocess.call('mkdir shockfiles', shell=True)

    for shock in range(start, args.end):

        placement_check = 1
        repeat = 0
        backup_pos = u.select_atoms('all').positions

        while placement_check == 1:

            # =================================================================
            # Collecting data for water relocation
            # =================================================================

            all_atoms = u.select_atoms('all')
            all_atoms_pos = all_atoms.positions
            atom_groups = ip.ag_extractor(all_atoms, args.index)
            water = ip.ag_finder(args.water_name, atom_groups)
            water_pos = water.positions
            membrane = ip.ag_finder(args.memname, atom_groups)
            membrane_pos = membrane.positions
            tj = u.trajectory[0]
            box_dimensions = tj.dimensions
            bin_size_a = args.bins*10
            nr_removed = args.removed
            search_volume = args.search

            # =================================================================
            # Clustering water particles in both compartements
            # =================================================================

            cluster_box = Cluster(all_atoms, box_dimensions, bin_size_a)

            lipid_bins = cluster_box.bin_converter_l(membrane_pos)
            lipid_bins_single = cl.multiples_remover(lipid_bins)

            bin_system = cluster_box.bin_system_maker(lipid_bins_single)
            bin_clusters, hb_bin_clusters = cluster_box.cluster_finder(bin_system)

            # =================================================================
            # Identifying water particles to reposition
            # =================================================================

            identify = Identifier(bin_clusters, box_dimensions, bin_size_a,
                                  water)
            identify_hb = Identifier(hb_bin_clusters, box_dimensions, bin_size_a,
                                     water)

            water_clusters = identify.cluster_selecter()
            water_clusters_hb = identify_hb.cluster_selecter()
            inner_cluster = water_clusters[0]
            outer_cluster = water_clusters[1]
            inner_cluster_hb = cl.multiples_remover(water_clusters_hb[0])

            if len(inner_cluster) < 100:
                rupture = 'yes'
                break

            np.random.shuffle(inner_cluster)
            water_bins = identify.bin_converter_w(water_pos)
            all_bins = identify.bin_converter_w(all_atoms_pos)

            if shocktype == 'steadystate':

                shock_go = 'no'

                if args.all_atom == 'no':
                    nr_water_inside = wi.water_counter(water_bins,
                                                       inner_cluster_hb)
                else:
                    nr_water_inside = wi.water_counter_aa(water_bins,
                                                          inner_cluster_hb,
                                                          args.oxygen_pos)

                if os.path.exists('initial_water_count.txt') == False:
                    with open('initial_water_count.txt', 'a') as data:
                        data.write(str(nr_water_inside))
                        amount_0 = nr_water_inside
                
                else:
                    with open('initial_water_count.txt', 'r') as data:
                        lines = data.readlines()
                        amount_0 = int(lines[0])

                difference = amount_0 - nr_water_inside
                with open('differences.txt', 'a') as data:
                    data.write(str(difference))
                    data.write('\n')

                eval_rounds = args.eval
                if (shock+1)%eval_rounds == 0:
                    shock_go = 'yes'
                    with open('differences.txt' ,'r') as data:
                        lines = data.readlines()[-10:]
                        diff_sum = 0
                        for i in lines:
                            diff_sum = diff_sum + int(i)
                        mean_diff = int(diff_sum/10)
                        
                    if mean_diff > 0:
                        shocktype = 'hypotonic'
                        nr_removed = mean_diff
                    else:
                        shocktype = 'hypertonic'
                        nr_removed = abs(mean_diff)
                    print(nr_removed)

            if shock_go == 'yes':
                
                if args.all_atom == 'no':
                    if shocktype == 'hypertonic':
                        remove_water = identify.index_finder_m(water_bins,
                                                               inner_cluster,
                                                               nr_removed)
                    else:
                        remove_water = identify.index_finder_m(water_bins,
                                                               outer_cluster,
                                                               nr_removed)
                else:
                    if shocktype == 'hypertonic':
                        remove_water = identify.index_finder_m_aa(water_bins,
                                                                  inner_cluster,
                                                                  args.oxygen_pos,
                                                                  nr_removed)
                    else:
                        remove_water = identify.index_finder_m_aa(water_bins,
                                                                  outer_cluster,
                                                                  args.oxygen_pos,
                                                                  nr_removed)

            # =================================================================
            # Calculating new positions for water particles
            # =================================================================

                if shocktype == 'hypertonic':

                    file_collection = Mover(outer_cluster,
                                            all_atoms,
                                            bin_size_a,
                                            nr_removed,
                                            box_dimensions,
                                            all_bins,
                                            water,
                                            search_volume)
                    repositioning_bins = \
                        file_collection.repositioning_bin_identifier()

                    if args.all_atom == 'no':
                        new_positions = file_collection.position_generator(
                            repositioning_bins)[0]
                        file_collection.water_repositioning_gro(remove_water,
                                                                new_positions,
                                                                gro_file)
                    else:
                        new_positions = file_collection.position_generator_aa(
                            repositioning_bins,
                            args.oxygen_pos)[0]
                        file_collection.water_repositioning_gro_aa(
                            remove_water,
                            new_positions,
                            gro_file,
                            args.oxygen_pos)

                else:
                    file_collection = Mover(inner_cluster,
                                            all_atoms,
                                            bin_size_a,
                                            nr_removed,
                                            box_dimensions,
                                            all_bins,
                                            water,
                                            search_volume)
                    repositioning_bins = \
                        file_collection.repositioning_bin_identifier()

                    if args.all_atom == 'no':
                        new_positions = file_collection.position_generator(
                            repositioning_bins)[0]
                        file_collection.water_repositioning_gro(remove_water,
                                                                new_positions,
                                                                gro_file)
                    else:
                        new_positions = file_collection.position_generator_aa(
                            repositioning_bins,
                            args.oxygen_pos)[0]
                        file_collection.water_repositioning_gro_aa(
                            remove_water,
                            new_positions,
                            gro_file,
                            args.oxygen_pos)

            if remember_ss == 'yes':
                shocktype = 'steadystate'
            # =================================================================
            # Data needed for relaxation run
            # =================================================================

            gro_file = 'osmotic_shock.gro'
            gro_file_1 = 'osmotic_shock1.gro'
            gro_file_2 = 'osmotic_shock2.gro'
            xtc_file = 'osmotic_shock.xtc'

            # =================================================================
            # Performing energy minimization if needed
            # =================================================================

            if args.emruns == 'yes' or repeat > 2:

                with open('errors.txt', 'a') as data:
                    data.write('EM executed at shock nr ' + str(shock))
                    data.write('\n')

                grompp_em = '{} grompp -f {} -c {} -p {} -maxwarn 1'
                grompp_command_em = grompp_em.format(args.gromacs,
                                                     mdp_min,
                                                     gro_file,
                                                     topology_file)

                if args.gmx_options == 'none':
                    mdrun = '{} mdrun -v'
                else:
                    options = ' '
                    with open(args.gmx_options, 'r') as data:
                        rl = data.readlines()
                        for i in rl:
                            options = options + i.strip() + ' '
                    mdrun = '{} mdrun' + options + '-v'

                mdrun_command_em = mdrun.format(args.gromacs)
                em_name_change_command = 'mv confout.gro {}'.format(gro_file)
                tpr_remove_command = 'rm topol.tpr'

                subprocess.call(grompp_command_em, shell=True)
                subprocess.call(mdrun_command_em, shell=True)
                subprocess.call(em_name_change_command, shell=True)
                subprocess.call(tpr_remove_command, shell=True)
                subprocess.call('rm step*', shell=True)

            # =================================================================
            # Executing the relaxation simulation
            # =================================================================

            grompp = '{} grompp -f {} -c {} -p {} -o {} -n {} -maxwarn 1'

            if args.gmx_options == 'none':
                mdrun = '{} mdrun -s {} -v -x {} -c {}'
            else:
                options = ' '
                with open(args.gmx_options, 'r') as data:
                    rl = data.readlines()
                    for i in rl:
                        options = options + i.strip() + ' '
                mdrun = '{} mdrun' + options + '-s {} -v -x {} -c {}'

            grompp_command_slow = grompp.format(args.gromacs,
                                                mdp_file2,
                                                gro_file,
                                                topology_file,
                                                tpr_file,
                                                args.index)
            mdrun_command_slow = mdrun.format(args.gromacs,
                                              tpr_file,
                                              xtc_file,
                                              gro_file_1)

            subprocess.call(grompp_command_slow, shell=True)
            subprocess.call(mdrun_command_slow, shell=True)

            grompp_command = grompp.format(args.gromacs,
                                           mdp_file,
                                           gro_file_1,
                                           topology_file,
                                           tpr_file,
                                           args.index)
            mdrun_command = mdrun.format(args.gromacs,
                                         tpr_file,
                                         xtc_file,
                                         gro_file_2)

            subprocess.call(grompp_command, shell=True)
            subprocess.call(mdrun_command, shell=True)

            file_list = os.listdir()
            lincs_warning = 0
            for file in file_list:
                if 'step' in str(file):
                    lincs_warning = 1

            if lincs_warning == 1:
                all_atoms.positions = backup_pos
                repeat = repeat + 1
                print(repeat)
                with open('errors.txt', 'a') as data:
                    data.write('Lincs warnings during shock nr ' + str(shock))
                    data.write('\n')
                subprocess.call('rm *# step*', shell=True)

            else:
                placement_check = 0

        if rupture == 'yes':
            break

        # =====================================================================
        # Renaming, saving and deleting files
        # =====================================================================

        # The old .gro file is saved under a new (unique) name
        fm.name_generator(gro_file, shock)

        new_coord = fm.gro_to_np(gro_file_2)
        u.select_atoms('all').positions = new_coord

        # renaming storing tpr file
        #fm.name_generator(tpr_file, shock)

        # Save one gro file of the vesicle only
        if shock == 0:
            all_atoms.write('vesicle_shock.gro')
            subprocess.call('mdvwhole -f vesicle_shock.gro', shell=True)
            subprocess.call('mv vesicle_shock.gro shockfiles', shell=True)

        # making cycle trajectory whole
        whole_command = 'mdvwhole -f shockfiles/vesicle_shock.gro -x ' + xtc_file + ' -o whole.xtc'
        subprocess.call(whole_command, shell=True)

        # making and saving an .xtc file
        fm.name_generator(xtc_file, shock)

        prev_gro = 'shockfiles/osmotic_shock_s' + str(shock - 1) + '.gro'
        if os.path.exists(prev_gro) == True:
            remove_old_gro = 'rm ' + prev_gro
            subprocess.call(remove_old_gro, shell=True)

        # Removing all backups and log files
        subprocess.call('rm *#', shell=True)
        subprocess.call('rm md.log', shell=True)

        # =====================================================================
        # Vesicle data acquisition
        # =====================================================================

        # Calculating the volume and surface area and writing to file
        if args.vesdata == 'yes':

            selection = 'name ' + args.cloudpoints
            whole_u = mda.Universe('whole.gro', 'whole.xtc')
            system_whole = whole_u.select_atoms('all')
            broken_system = VolArea(system_whole,
                                    box_dimensions,
                                    selection)
            try:
                vol_area = broken_system.volume_area()
                if args.ions == 'yes':
                    concentration_system = IonConcentration(bin_size_a,
                                                            box_dimensions,
                                                            water_clusters)

                    ions_pos = ip.ag_finder(args.ions_name,
                                            atom_groups).positions

                    ion_bins = concentration_system.bin_converter_i(ions_pos)
                    nr_ions = concentration_system.ion_counter(ion_bins)
                    inner_ions = nr_ions[0]
                    outer_ions = nr_ions[1]
                    inner_conc = vd.concentration(vol_area[2], inner_ions)
                    outer_conc = vd.concentration(vol_area[3], outer_ions)
                else:
                    inner_conc = 0
                    outer_conc = 0

            except IndexError:
                vol_area = [0, 0, 0]
                inner_conc = 0
                outer_conc = 0

            if os.path.exists('vesicle_data.txt') == False:
                with open('vesicle_data.txt', 'a') as data:
                    data.write('{0:10} {1:20} {2:20} {3:20} {4:20} {5:20} {6:20} {7:20} {8:20}'.format(
                               'shock nr',
                               'inner area (nm^2)',
                               'outer area (nm^2)',
                               'volume (nm^3)',
                               'inner_conc (mol/L)',
                               'outer_conc (mol/L)',
                               'reduced vol. diff.',
                               'reduced area diff.',
                               'sphericity'
                               ))
                    data.write('\n')
                    data.write('-'*169)
                    data.write('\n')

                    V0 = vol_area[2]
                    Ad0 = vol_area[1] - vol_area[0]

            else:
                with open('vesicle_data.txt', 'r') as data:
                    lines = data.readlines()
                    V0 = float(lines[2].split()[3])
                    Ad0 = float(lines[2].split()[2]) - float(lines[2].split()[1])

            # Calculating reduced volume and reduced area difference
            shape_data = vd.shape(V0, Ad0, vol_area[2], vol_area[0], vol_area[1])
            red_vol_diff = shape_data[0]
            red_area_diff = shape_data[1]

            # Calculating the sphericity parameter delta
            cloud = u.select_atoms(selection).positions
            gyr_tens = vd.gyration_tensor(cloud)
            sphericity = vd.delta(gyr_tens)

            with open('vesicle_data.txt', 'a') as data:

                data.write('{0:<10d} {1:<20.2f} {2:<20.2f} {3:<20.2f} {4:<20.5f} {5:<20.5f} {6:<20.5f} {7:<20.5f} {8:<20.5f}'.format(
                               shock,
                               vol_area[0],
                               vol_area[1],
                               vol_area[2],
                               inner_conc,
                               outer_conc,
                               red_vol_diff,
                               red_area_diff,
                               sphericity))
                data.write('\n')

    # =========================================================================
    # Steady state simulation
    # =========================================================================

    if args.steadystate == 'yes' or rupture == 'yes':

        fm.mdp_value_changer(mdp_file,
                             'new.mdp',
                             'nsteps',
                             args.nr_steadystate)

        grompp = '{} grompp -f {} -c {} -p {} -o {} -n {}'
        grompp_command = grompp.format(args.gromacs,
                                       mdp_file,
                                       gro_file,
                                       topology_file,
                                       tpr_file,
                                       args.index)

        mdrun = '{} mdrun -s {} -v -x {} -c {}'
        mdrun_command = mdrun.format(args.gromacs,
                                     tpr_file,
                                     'osmotic_shock.xtc',
                                     'steady_state.gro')

        subprocess.call(grompp_command, shell=True)
        subprocess.call(mdrun_command, shell=True)


if __name__ == '__main__':
    main()
